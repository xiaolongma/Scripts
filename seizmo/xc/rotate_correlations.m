function [nn,ne,en,ee]=rotate_correlations(nn,ne,en,ee)
%ROTATE_CORRELATIONS    Rotates correlations to EE/EN/NE/NN or RR/RT/TR/TT
%
%    Usage:    [rr,rt,tr,tt]=rotate_correlations(nn,ne,en,ee)
%              [nn,ne,en,ee]=rotate_correlations(rr,rt,tr,tt)
%
%    Description:
%     [RR,RT,TR,TT]=ROTATE_CORRELATIONS(NN,NE,EN,EE) rotates horizontal
%     correlogram sets is SEIZMO structs NN, NE, EN, EE from North & East
%     orientations to pairwise radial and transverse directions (defined
%     by the azimuths between each pair of stations).  Input correlograms
%     are expected to be between Eest and North components (so make sure to
%     have rotated all records to this system prior to correlation).  This
%     is only compatible with correlograms generated by CORRELATE due to
%     header field arrangement (so you need to mimic that to use this
%     function).  Records with the same index across each dataset must
%     correspond to the same pair and the same lags (for example this
%     applies to NN(3), NE(3), EN(3), & EE(3)).
%
%     [NN,NE,EN,EE]=ROTATE_CORRELATIONS(RR,RT,TR,TT) rotates horizontal
%     correlograms from pairwise radial & transverse to North & East.  This
%     is mainly useful for testing purposes.
%
%    Notes:
%     - The algorithm is published in:
%        Lin, Moschetti, & Ritzwoller 2008, GJI,
%         doi: 10.1111/j.1365-246X.2008.03720.x
%     - The .name fields are altered to match the header info.
%     - Each set in NN/NE/EN/EE must have the same begin time, sample rate
%       and number of points.  As an example, that means NN(3), NE(3),
%       EN(3), & EE(3) must match on the corresponding header fields.
%     - Does not handle mixed cases.  So no converting some sets to N/E and
%       others to R/T in the same command!
%
%    Header changes:
%     KCMPNM & KT3 are changed to end with R/T or N/E.
%     CMPINC/CMPAZ & USER2/USER3 are updated.
%
%    Examples:
%     % Rotate, Correlate, Separate, Rotate:
%     data=rotate(data,'to',0,'kcmpnm1','N','kcmpnm2','E');
%     xc=correlate(data,'mcxc');
%     [axc,xc]=split_auto_correlations(xc,false);
%     [in,set,cmp]=horz_correlations_sets(xc);
%     [rr,rt,tr,tt]=rotate_correlations(...
%         xc(cmp==1),xc(cmp==2),xc(cmp==3),xc(cmp==4));
%
%    See also: CORRELATE, REVERSE_CORRELATIONS, HORZ_CORRELATIONS_SETS
%              SPLIT_AUTO_CORRELATIONS, ROTATE

%     Version History:
%        June 10, 2010 - initial version
%        June 13, 2010 - major bugfix
%        June 17, 2010 - more checks for no rotatible records
%        July  2, 2010 - fix cat warnings (dumb Matlab feature)
%        Feb.  7, 2012 - update cmpaz/user3 fields (azimuths), doc update
%        Nov.  7, 2012 - rewrite based on split input/output
%        Jan. 28, 2013 - doc update
%        Sep.  9, 2013 - fixed a bug for dep* update
%        Sep. 23, 2013 - improved example, dropped deprecated function
%                        split_horz_correlations
%
%     Written by Garrett Euler (ggeuler at wustl dot edu)
%     Last Updated Sep. 23, 2013 at 13:30 GMT

% todo:

% check nargin
error(nargchk(4,4,nargin));

% check structs
error(seizmocheck(nn,'dep'));
error(seizmocheck(ne,'dep'));
error(seizmocheck(en,'dep'));
error(seizmocheck(ee,'dep'));

% require xc dataset
if(~isxc(nn) || ~isxc(ne) || ~isxc(en) || ~isxc(ee))
    error('seizmo:rotate_correlations:badInput',...
        'NN, NE, EN & EE must be correlations!');
end

% number of pairings
npairs=numel(nn);
if(~isequal(npairs,numel(ne),numel(en),numel(ee)))
    error('seizmo:rotate_correlations:badInput',...
        'NN, NE, EN & EE datasets are not the same size!');
end

% turn off struct checking
oldseizmocheckstate=seizmocheck_state(false);

% attempt header check
try
    % check headers
    nn=checkheader(nn,...
        'MULCMP_DEP','ERROR',...
        'NONTIME_IFTYPE','ERROR',...
        'FALSE_LEVEN','ERROR',...
        'UNSET_ST_LATLON','ERROR',...
        'UNSET_EV_LATLON','ERROR');
    ne=checkheader(ne,...
        'MULCMP_DEP','ERROR',...
        'NONTIME_IFTYPE','ERROR',...
        'FALSE_LEVEN','ERROR',...
        'UNSET_ST_LATLON','ERROR',...
        'UNSET_EV_LATLON','ERROR');
    en=checkheader(en,...
        'MULCMP_DEP','ERROR',...
        'NONTIME_IFTYPE','ERROR',...
        'FALSE_LEVEN','ERROR',...
        'UNSET_ST_LATLON','ERROR',...
        'UNSET_EV_LATLON','ERROR');
    ee=checkheader(ee,...
        'MULCMP_DEP','ERROR',...
        'NONTIME_IFTYPE','ERROR',...
        'FALSE_LEVEN','ERROR',...
        'UNSET_ST_LATLON','ERROR',...
        'UNSET_EV_LATLON','ERROR');
    
    % turn off header checking
    oldcheckheaderstate=checkheader_state(false);
catch
    % toggle checking back
    seizmocheck_state(oldseizmocheckstate);
    
    % rethrow error
    error(lasterror);
end

% extract header info & data
try
    % verbosity
    verbose=seizmoverbose;
    
    % grab necessary header info
    [b,npts,delta,st,ev,stnm,evnm,scmp,ecmp]=getheader(nn,'b',...
        'npts','delta','st','ev','kname','kt','cmp','user');
    [b2,npts2,delta2,st2,ev2,stnm2,evnm2,scmp2,ecmp2]=getheader(ne,'b',...
        'npts','delta','st','ev','kname','kt','cmp','user');
    [b3,npts3,delta3,st3,ev3,stnm3,evnm3,scmp3,ecmp3]=getheader(en,'b',...
        'npts','delta','st','ev','kname','kt','cmp','user');
    [b4,npts4,delta4,st4,ev4,stnm4,evnm4,scmp4,ecmp4]=getheader(ee,'b',...
        'npts','delta','st','ev','kname','kt','cmp','user');
    mi=ecmp(:,1);   si=ecmp(:,2);   mi2=ecmp2(:,1); si2=ecmp2(:,2);
    mi3=ecmp3(:,1); si3=ecmp3(:,2); mi4=ecmp4(:,1); si4=ecmp4(:,2);
    ecmp=ecmp(:,3:4); ecmp2=ecmp2(:,3:4);
    ecmp3=ecmp3(:,3:4); ecmp4=ecmp4(:,3:4);
    
    % for rt case
    [az,gcp]=getheader(nn,'az','gcp');
catch
    % toggle checking back
    seizmocheck_state(oldseizmocheckstate);
    checkheader_state(oldcheckheaderstate);
    
    % rethrow error
    error(lasterror);
end

% allow component code to be broken into rate/gain/orientation codes
mc1=char(evnm(:,4));  mc2=char(evnm2(:,4));
mc3=char(evnm3(:,4)); mc4=char(evnm4(:,4));
sc1=char(stnm(:,4));  sc2=char(stnm2(:,4));
sc3=char(stnm3(:,4)); sc4=char(stnm4(:,4));

% need nn, ne, en & ee to match on several fields
if(~isequal(b,b2,b3,b4) ...
        || ~isequal(delta,delta2,delta3,delta4) ...
        || ~isequal(npts,npts2,npts3,npts4) ...
        || ~isequal(st(:,1:2),st2(:,1:2),st3(:,1:2),st4(:,1:2)) ...
        || ~isequal(ev(:,1:2),ev2(:,1:2),ev3(:,1:2),ev4(:,1:2)) ...
        || ~isequal(stnm(:,1:3),stnm2(:,1:3),stnm3(:,1:3),stnm4(:,1:3)) ...
        || ~isequal(evnm(:,1:3),evnm2(:,1:3),evnm3(:,1:3),evnm4(:,1:3)) ...
        || ~isequal(sc1(:,1:2),sc2(:,1:2),sc3(:,1:2),sc4(:,1:2)) ...
        || ~isequal(mc1(:,1:2),mc2(:,1:2),mc3(:,1:2),mc4(:,1:2)))
    error('seizmo:rotate_correlations:badInput',...
        'NN, NE, EN & EE are not synced!');
end
clear b2 b3 b4 delta2 delta3 delta4 npts2 npts3 npts4;
clear st2 st3 st4 ev2 ev3 ev4 stnm2 stnm3 stnm4 evnm2 evnm3 evnm4;
clear mc2 mc3 mc4 sc2 sc3 sc4;

% require north & east orientation or pairwise radial & transverse
if(any([scmp(:,1);scmp2(:,1);scmp3(:,1);scmp4(:,1)]~=90) ...
        || any([ecmp(:,1);ecmp2(:,1);ecmp3(:,1);ecmp4(:,1)]~=90))
    error('seizmo:rotate_correlations:badInput',...
        'All correlations must be between horizontals (CMPINC==90)!');
end
try
    isne=true;
    if(any([scmp(:,2);ecmp(:,2)]~=0))
        error('seizmo:rotate_correlations:badInput',...
            'NN must have CMPAZ==0 & USER3==0!');
    elseif(any(scmp2(:,2)~=90) || any(ecmp2(:,2)~=0))
        error('seizmo:rotate_correlations:badInput',...
            'NE must have CMPAZ==90 & USER3==0!');
    elseif(any(scmp3(:,2)~=0) || any(ecmp3(:,2)~=90))
        error('seizmo:rotate_correlations:badInput',...
            'EN must have CMPAZ==0 & USER3==90!');
    elseif(any([scmp4(:,2);ecmp4(:,2)]~=90))
        error('seizmo:rotate_correlations:badInput',...
            'EE must have CMPAZ==90 & USER3==90!');
    end
catch
    isne=false; % RT?
    if(any(abs(azdiff(scmp(:,2),gcp))>1) ...
            || any(abs(azdiff(ecmp(:,2),az))>1))
        error('seizmo:rotate_correlations:badInput',...
            'RR must have CMPAZ==GCP & USER3==AZ!');
    elseif(any(abs(azdiff(scmp2(:,2),gcp+90))>1) ...
            || any(abs(azdiff(ecmp2(:,2),az))>1))
        error('seizmo:rotate_correlations:badInput',...
            'RT must have CMPAZ==GCP+90 & USER3==AZ!');
    elseif(any(abs(azdiff(scmp3(:,2),gcp))>1) ...
            || any(abs(azdiff(ecmp3(:,2),az+90))>1))
        error('seizmo:rotate_correlations:badInput',...
            'TR must have CMPAZ==GCP & USER3==AZ+90!');
    elseif(any(abs(azdiff(scmp4(:,2),gcp+90))>1) ...
            || any(abs(azdiff(ecmp4(:,2),az+90))>1))
        error('seizmo:rotate_correlations:badInput',...
            'TT must have CMPAZ==GCP+90 & USER3==AZ+90!');
    end
end
clear scmp2 scmp3 scmp4 ecmp2 ecmp3 ecmp4;

% handle rt2ne
if(~isne); az=-az; gcp=-gcp; end

% rotation
[nnmin,nnmax,nnmen]=deal(nan(npairs,1));
[nemin,nemax,nemen]=deal(nan(npairs,1));
[enmin,enmax,enmen]=deal(nan(npairs,1));
[eemin,eemax,eemen]=deal(nan(npairs,1));
for i=1:npairs
    % precompute angle terms
    cc=cosd(az(i))*cosd(gcp(i));
    cs=cosd(az(i))*sind(gcp(i));
    sc=sind(az(i))*cosd(gcp(i));
    ss=sind(az(i))*sind(gcp(i));
    
    % Rotate
    [nn(i).dep,ne(i).dep,en(i).dep,ee(i).dep]=deal(...
         nn(i).dep*cc+ne(i).dep*cs+en(i).dep*sc+ee(i).dep*ss,...
        -nn(i).dep*cs+ne(i).dep*cc-en(i).dep*ss+ee(i).dep*sc,...
        -nn(i).dep*sc-ne(i).dep*ss+en(i).dep*cc+ee(i).dep*cs,...
         nn(i).dep*ss-ne(i).dep*sc-en(i).dep*cs+ee(i).dep*cc);
    
    % update dep*
    if(size(nn(i).dep,1)>0)
        nnmin(i)=min(nn(i).dep);
        nnmax(i)=max(nn(i).dep);
        nnmen(i)=nanmean(nn(i).dep);
        nemin(i)=min(ne(i).dep);
        nemax(i)=max(ne(i).dep);
        nemen(i)=nanmean(ne(i).dep);
        enmin(i)=min(en(i).dep);
        enmax(i)=max(en(i).dep);
        enmen(i)=nanmean(en(i).dep);
        eemin(i)=min(ee(i).dep);
        eemax(i)=max(ee(i).dep);
        eemen(i)=nanmean(ee(i).dep);
    end
    
    if(verbose); print_time_left(i,npairs); end
end

% update headers
if(isne)
    mc1=strcat(mc1(:,1:2),'N'); mc2=strcat(mc1(:,1:2),'E');
    sc1=strcat(sc1(:,1:2),'N'); sc2=strcat(sc1(:,1:2),'E');
    nn=changeheader(nn,'depmin',nnmin,'depmax',nnmax,'depmen',nnmen,...
        'kt3',mc1,'kcmpnm',sc1,'user3',0,'cmpaz',0);
    ne=changeheader(ne,'depmin',nemin,'depmax',nemax,'depmen',nemen,...
        'kt3',mc1,'kcmpnm',sc2,'user3',0,'cmpaz',90);
    en=changeheader(en,'depmin',enmin,'depmax',enmax,'depmen',enmen,...
        'kt3',mc2,'kcmpnm',sc1,'user3',90,'cmpaz',0);
    ee=changeheader(ee,'depmin',eemin,'depmax',eemax,'depmen',eemen,...
        'kt3',mc2,'kcmpnm',sc2,'user3',90,'cmpaz',90);
    
    % rename
    digits=['%0' num2str(fix(log10(max(...
        [mi;mi2;mi3;mi4;si;si2;si3;si4])))+1) 'd'];
    name=strcat('CORR_-_MASTER_-_REC',num2str(mi,digits),'_-_',...
        evnm(:,1),'.',evnm(:,2),'.',evnm(:,3),'.',mc1,'_-_SLAVE_-_REC',...
        num2str(si,digits),'_-_',stnm(:,1),'.',stnm(:,2),'.',stnm(:,3),...
        '.',sc1);
    [nn.name]=deal(name{:});
    name=strcat('CORR_-_MASTER_-_REC',num2str(mi2,digits),'_-_',...
        evnm(:,1),'.',evnm(:,2),'.',evnm(:,3),'.',mc1,'_-_SLAVE_-_REC',...
        num2str(si2,digits),'_-_',stnm(:,1),'.',stnm(:,2),'.',stnm(:,3),...
        '.',sc2);
    [ne.name]=deal(name{:});
    name=strcat('CORR_-_MASTER_-_REC',num2str(mi3,digits),'_-_',...
        evnm(:,1),'.',evnm(:,2),'.',evnm(:,3),'.',mc2,'_-_SLAVE_-_REC',...
        num2str(si3,digits),'_-_',stnm(:,1),'.',stnm(:,2),'.',stnm(:,3),...
        '.',sc1);
    [en.name]=deal(name{:});
    name=strcat('CORR_-_MASTER_-_REC',num2str(mi4,digits),'_-_',...
        evnm(:,1),'.',evnm(:,2),'.',evnm(:,3),'.',mc2,'_-_SLAVE_-_REC',...
        num2str(si4,digits),'_-_',stnm(:,1),'.',stnm(:,2),'.',stnm(:,3),...
        '.',sc2);
    [ee.name]=deal(name{:});
else
    taz=lonmod(az+90);
    tgcp=lonmod(gcp+90);
    mc1=strcat(mc1(:,1:2),'R'); mc2=strcat(mc1(:,1:2),'T');
    sc1=strcat(sc1(:,1:2),'R'); sc2=strcat(sc1(:,1:2),'T');
    nn=changeheader(nn,'depmin',nnmin,'depmax',nnmax,'depmen',nnmen,...
        'kt3',mc1,'kcmpnm',sc1,'user3',az,'cmpaz',gcp);
    ne=changeheader(ne,'depmin',nemin,'depmax',nemax,'depmen',nemen,...
        'kt3',mc1,'kcmpnm',sc2,'user3',az,'cmpaz',tgcp);
    en=changeheader(en,'depmin',enmin,'depmax',enmax,'depmen',enmen,...
        'kt3',mc2,'kcmpnm',sc1,'user3',taz,'cmpaz',gcp);
    ee=changeheader(ee,'depmin',eemin,'depmax',eemax,'depmen',eemen,...
        'kt3',mc2,'kcmpnm',sc2,'user3',taz,'cmpaz',tgcp);
    
    % rename
    digits=['%0' num2str(fix(log10(max(...
        [mi;mi2;mi3;mi4;si;si2;si3;si4])))+1) 'd'];
    name=strcat('CORR_-_MASTER_-_REC',num2str(mi,digits),'_-_',...
        evnm(:,1),'.',evnm(:,2),'.',evnm(:,3),'.',mc1,'_-_SLAVE_-_REC',...
        num2str(si,digits),'_-_',stnm(:,1),'.',stnm(:,2),'.',stnm(:,3),...
        '.',sc1);
    [nn.name]=deal(name{:});
    name=strcat('CORR_-_MASTER_-_REC',num2str(mi2,digits),'_-_',...
        evnm(:,1),'.',evnm(:,2),'.',evnm(:,3),'.',mc1,'_-_SLAVE_-_REC',...
        num2str(si2,digits),'_-_',stnm(:,1),'.',stnm(:,2),'.',stnm(:,3),...
        '.',sc2);
    [ne.name]=deal(name{:});
    name=strcat('CORR_-_MASTER_-_REC',num2str(mi3,digits),'_-_',...
        evnm(:,1),'.',evnm(:,2),'.',evnm(:,3),'.',mc2,'_-_SLAVE_-_REC',...
        num2str(si3,digits),'_-_',stnm(:,1),'.',stnm(:,2),'.',stnm(:,3),...
        '.',sc1);
    [en.name]=deal(name{:});
    name=strcat('CORR_-_MASTER_-_REC',num2str(mi4,digits),'_-_',...
        evnm(:,1),'.',evnm(:,2),'.',evnm(:,3),'.',mc2,'_-_SLAVE_-_REC',...
        num2str(si4,digits),'_-_',stnm(:,1),'.',stnm(:,2),'.',stnm(:,3),...
        '.',sc2);
    [ee.name]=deal(name{:});
end

end


function [lgc]=isxc(data)
[m,s]=getheader(data,'kuser0','kuser1');
if(all(strcmp(m,'MASTER') & strcmp(s,'SLAVE'))); lgc=true;
else lgc=false;
end
end
